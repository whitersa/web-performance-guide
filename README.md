# web-performance-guide

## Cache
+ 静态页面

    这种方案适用于url请求的页面内容几乎不会变动，浏览器或者cdn分发服务可以长期缓存这份资源。只要不超过max-age期限，资源不会对服务器发起请求而是直接从缓存获取。

    > Cache-Control: max-age=31536000 // 31536000是一年(365天)的秒数

    通常来讲请求的资源文件名会包含一个独一无二的字符串，可能是版本信息、修改日期、或者基于内容得出的hash值。

+ 非静态页面
  
    针对这些页面内容很可能发生变化的情况，例如博客文章等，必须要向服务器确认是否可以采用本地缓存。
    本地会以缓存资源的修改时间向服务器询问，如果确认没有发生更改则可以继续使用缓存，否则就要从服务器拉取新的资源内容。
    
    > Cache-Control: no-cache 
    |     可选值      |                         含义                            |
    |:---------------:|:-----------------------------------------------------: |
    | no-cache        | 不代表不使用缓存，而是要先向服务器询问再决定是否使用缓存   |
    | no-store        | 告诉浏览器永远不要缓存                                  | 
    | must-revalidate | 不代表必须要重新验证，而是在超过max-age以后必须要重新验证 |

    服务器端可以在响应头部添加E-tag(关于版本信息的id)或者Last-Modified信息。下次客户端获取资源时，会分别通过If-None-Match(E-Tag)和If-Modified-Since(对应服务器返回的Last-Modified)回传拥有的内容的值，服务器从而做出响应告诉客户端可以使用你本地已有的内容或者只是简单的返回‘HTTP 304’。
    
    如果服务器不能响应E-Tag或者Last-Modified，那么就总是将请求的文本直接返回。

+ 一个错误的例子
    
    > Cache-Control: must-revalidate, max-age=600

    假如你需要获取html、script和style三个文件，在第一次请求到这些文件后进行了缓存，在接下来十分钟内如果再次请求这个页面，本地缓存丢失了其中一个文件（可能是用户错误操作删掉了），而服务器中的三个文件都进行了改动，那么页面将会拿到缓存中的两个旧文件和服务器中的一个新文件，页面就会出问题。所以说这是一个很不好的做法。
    
    强制刷新从而全部重新拉取资源文件确实可以解决这个问题，但是用户对你的信任也会减少。
    service-worker也可以改善此问题，但是部分老旧的浏览器没法使用。

